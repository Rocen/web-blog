import{_ as a,c as i,o as n,ae as e}from"./chunks/framework.Bl5GZLa3.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/webpack热更新原理.md","filePath":"engineering/webpack热更新原理.md"}'),t={name:"engineering/webpack热更新原理.md"};function l(h,s,r,o,p,k){return n(),i("div",null,s[0]||(s[0]=[e(`<p>Webpack 热更新（Hot Module Replacement, HMR）的核心原理是通过动态替换修改的模块代码，实现<strong>不刷新页面</strong>即可更新应用状态。其流程可拆解为以下几个关键步骤：</p><hr><h3 id="_1-建立通信通道" tabindex="-1">1. <strong>建立通信通道</strong> <a class="header-anchor" href="#_1-建立通信通道" aria-label="Permalink to &quot;1. **建立通信通道**&quot;">​</a></h3><ul><li><strong>WebSocket 连接</strong>：Webpack DevServer 启动时，会创建一个 WebSocket 服务端，与浏览器客户端建立长连接。</li><li><strong>双向通信</strong>：通过 WebSocket 实现服务端与客户端的实时消息传递（如文件修改通知、更新请求等）。</li></ul><hr><h3 id="_2-文件监听与编译" tabindex="-1">2. <strong>文件监听与编译</strong> <a class="header-anchor" href="#_2-文件监听与编译" aria-label="Permalink to &quot;2. **文件监听与编译**&quot;">​</a></h3><ul><li><strong>监听文件变化</strong>：Webpack 通过 <code>watch</code> 模式实时监听源代码文件的变化。</li><li><strong>增量编译</strong>：文件修改后，Webpack 仅重新编译受影响的模块，生成新的编译结果（包括更新的模块代码和生成的 <code>[hash].hot-update.json</code> 和 <code>[hash].hot-update.js</code> 补丁文件）。</li></ul><hr><h3 id="_3-推送更新通知" tabindex="-1">3. <strong>推送更新通知</strong> <a class="header-anchor" href="#_3-推送更新通知" aria-label="Permalink to &quot;3. **推送更新通知**&quot;">​</a></h3><ul><li><strong>Hash 对比</strong>：服务端将新编译的 <code>hash</code> 值通过 WebSocket 发送给客户端。</li><li><strong>客户端检查更新</strong>：客户端通过 <code>window.__webpack_hash__</code> 对比本地 <code>hash</code>，若不一致则发起更新请求。</li></ul><hr><h3 id="_4-获取更新资源" tabindex="-1">4. <strong>获取更新资源</strong> <a class="header-anchor" href="#_4-获取更新资源" aria-label="Permalink to &quot;4. **获取更新资源**&quot;">​</a></h3><ul><li><strong>JSONP 动态加载</strong>：客户端通过 <code>JSONP</code> 请求获取两个文件： <ol><li><strong><code>[hash].hot-update.json</code></strong>：描述哪些模块需要更新。</li><li><strong><code>[hash].hot-update.js</code></strong>：包含更新后的模块代码。</li></ol></li><li><strong>插入新代码</strong>：动态创建 <code>&lt;script&gt;</code> 标签加载补丁脚本，将新模块代码注入运行环境。</li></ul><hr><h3 id="_5-模块替换与热更新" tabindex="-1">5. <strong>模块替换与热更新</strong> <a class="header-anchor" href="#_5-模块替换与热更新" aria-label="Permalink to &quot;5. **模块替换与热更新**&quot;">​</a></h3><ul><li><strong>模块热替换</strong>：调用 <code>HotModuleReplacementPlugin</code> 生成的 <code>HMR Runtime</code> 代码，执行以下操作： <ol><li><strong>删除旧模块</strong>：从模块缓存中移除旧模块。</li><li><strong>应用新模块</strong>：将新模块代码加入缓存，替换旧模块。</li><li><strong>冒泡更新</strong>：从被修改的模块开始，向上遍历依赖树，触发所有父模块的 <code>accept</code> 回调。</li></ol></li><li><strong>自定义处理</strong>：如果模块定义了 <code>module.hot.accept</code> 回调（如 React 组件的热更新），则执行自定义更新逻辑（如重新渲染组件但保留状态）。</li></ul><hr><h3 id="_6-异常处理" tabindex="-1">6. <strong>异常处理</strong> <a class="header-anchor" href="#_6-异常处理" aria-label="Permalink to &quot;6. **异常处理**&quot;">​</a></h3><ul><li><strong>更新失败回退</strong>：若热更新过程中发生错误（如模块未处理 <code>accept</code>），则自动降级为刷新整个页面（Live Reload）。</li></ul><hr><h3 id="关键代码示例" tabindex="-1">关键代码示例 <a class="header-anchor" href="#关键代码示例" aria-label="Permalink to &quot;关键代码示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Webpack 配置启用 HMR</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">devServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  hot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开启 HMR</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> webpack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HotModuleReplacementPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注入 HMR Runtime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模块自定义热更新逻辑（如 React 组件）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./App.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 重新渲染组件，保留状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;, document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="流程示意图" tabindex="-1">流程示意图 <a class="header-anchor" href="#流程示意图" aria-label="Permalink to &quot;流程示意图&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>文件修改 → Webpack 监听并编译 → 服务端推送新 Hash → 客户端请求补丁文件 → 动态加载新模块 → 替换旧模块 → 触发更新回调</span></span></code></pre></div><hr><h3 id="核心优势" tabindex="-1">核心优势 <a class="header-anchor" href="#核心优势" aria-label="Permalink to &quot;核心优势&quot;">​</a></h3><ul><li><strong>状态保留</strong>：避免页面刷新导致的应用状态丢失（如表单输入、弹窗状态）。</li><li><strong>快速反馈</strong>：仅更新修改的部分，减少等待完整编译和刷新的时间。</li><li><strong>开发体验提升</strong>：实现真正的“所见即所得”开发模式。</li></ul><hr><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>Webpack HMR 的本质是<strong>动态模块替换系统</strong>，通过 WebSocket 通信、增量编译、JSONP 加载补丁和模块热替换机制，实现高效的无刷新更新。其设计充分利用了 Webpack 模块化架构和浏览器动态执行能力，是现代前端工程化的重要实践之一。</p>`,31)]))}const g=a(t,[["render",l]]);export{c as __pageData,g as default};
