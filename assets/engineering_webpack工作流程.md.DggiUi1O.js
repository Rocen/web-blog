import{_ as e,c as l,o as i,ae as n}from"./chunks/framework.Bl5GZLa3.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/webpack工作流程.md","filePath":"engineering/webpack工作流程.md"}'),t={name:"engineering/webpack工作流程.md"};function r(s,o,a,d,c,p){return i(),l("div",null,o[0]||(o[0]=[n(`<p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包工具，其核心工作流程可以划分为 <strong>初始化配置、模块解析、依赖图构建、代码生成与优化、输出结果</strong> 五个关键阶段。以下是详细的工作流程描述：</p><hr><h3 id="一、初始化阶段" tabindex="-1">一、初始化阶段 <a class="header-anchor" href="#一、初始化阶段" aria-label="Permalink to &quot;一、初始化阶段&quot;">​</a></h3><ol><li><p><strong>读取配置</strong></p><ul><li>读取 <code>webpack.config.js</code> 或命令行参数，合并默认配置（<code>webpack</code> 内置的 <code>defaultConfig</code>）。</li><li>初始化 <strong>Compiler 对象</strong>（核心控制类），负责整个打包过程的调度。</li></ul></li><li><p><strong>加载插件</strong></p><ul><li>根据配置中的 <code>plugins</code> 字段，实例化所有插件，并调用插件的 <code>apply</code> 方法，将 <code>Compiler</code> 对象暴露给插件。</li></ul></li><li><p><strong>环境准备</strong></p><ul><li>注册 <code>Compiler</code> 的生命周期钩子（如 <code>beforeRun</code>, <code>run</code>, <code>compile</code> 等），供插件监听。</li></ul></li></ol><hr><h3 id="二、模块解析与依赖图构建" tabindex="-1">二、模块解析与依赖图构建 <a class="header-anchor" href="#二、模块解析与依赖图构建" aria-label="Permalink to &quot;二、模块解析与依赖图构建&quot;">​</a></h3><ol><li><p><strong>确定入口（Entry）</strong></p><ul><li>根据配置的 <code>entry</code> 字段找到入口文件（如 <code>src/index.js</code>）。</li></ul></li><li><p><strong>模块解析（Resolve）</strong></p><ul><li><strong>递归分析依赖</strong>：从入口文件开始，解析 <code>import</code>/<code>require</code> 语句，找到所有依赖的模块路径。</li><li><strong>路径解析</strong>：通过 <code>resolve</code> 配置（如别名、扩展名自动补全）确定模块的绝对路径。</li><li><strong>加载 Loader</strong>：根据 <code>module.rules</code> 匹配文件类型，调用对应的 Loader 链（从右到左）对文件内容进行转换（如将 <code>.scss</code> 转成 CSS 再转 JS）。</li></ul></li><li><p><strong>生成模块对象（Module）</strong></p><ul><li>每个模块被解析为一个 <code>Module</code> 对象，包含： <ul><li>模块的唯一标识（ID）</li><li>模块的源代码（经过 Loader 处理后的 JS 代码）</li><li>依赖的模块路径列表（<code>dependencies</code>）</li></ul></li></ul></li><li><p><strong>构建依赖图（Dependency Graph）</strong></p><ul><li>通过递归遍历所有模块的依赖关系，形成模块间的依赖关系图（树状或图结构）。</li></ul></li></ol><hr><h3 id="三、代码生成与优化" tabindex="-1">三、代码生成与优化 <a class="header-anchor" href="#三、代码生成与优化" aria-label="Permalink to &quot;三、代码生成与优化&quot;">​</a></h3><ol><li><p><strong>生成 Chunk</strong></p><ul><li>根据入口文件和动态导入（<code>import()</code>）分割代码块（Chunk）。</li><li>每个入口文件对应一个初始 Chunk，动态导入的模块会生成独立的 Chunk。</li></ul></li><li><p><strong>优化处理（Optimization）</strong></p><ul><li><strong>Tree Shaking</strong>：通过 <code>ES Module</code> 静态语法标记未使用的代码，并在生产环境移除。</li><li><strong>代码分割（Code Splitting）</strong>：按需加载的代码块、公共模块提取（如 <code>SplitChunksPlugin</code>）。</li><li><strong>作用域提升（Scope Hoisting）</strong>：合并模块作用域，减少闭包数量，优化运行性能。</li><li><strong>压缩混淆</strong>：使用 <code>TerserPlugin</code> 压缩 JS，<code>CssMinimizerPlugin</code> 压缩 CSS。</li></ul></li><li><p><strong>应用插件优化</strong></p><ul><li>插件通过监听 <code>Compiler</code> 的钩子（如 <code>optimizeChunks</code>, <code>optimizeModules</code>）介入优化过程。</li></ul></li></ol><hr><h3 id="四、输出阶段-emit" tabindex="-1">四、输出阶段（Emit） <a class="header-anchor" href="#四、输出阶段-emit" aria-label="Permalink to &quot;四、输出阶段（Emit）&quot;">​</a></h3><ol><li><p><strong>生成资源（Assets）</strong></p><ul><li>根据 Chunk 和 <code>output</code> 配置，生成最终输出文件： <ul><li><strong>Bundle 文件</strong>：主 JS 文件、按需加载的 Chunk 文件。</li><li><strong>辅助文件</strong>：CSS 文件（通过 <code>MiniCssExtractPlugin</code>）、图片、字体等。</li></ul></li></ul></li><li><p><strong>文件写入</strong></p><ul><li>调用 <code>Compilation</code> 的 <code>emitAssets</code> 方法，将文件写入 <code>output.path</code> 指定的目录。</li><li>文件名可能包含哈希（如 <code>[contenthash]</code>），用于缓存策略。</li></ul></li><li><p><strong>生成 Manifest</strong></p><ul><li>记录模块 ID 与 Chunk 的映射关系，供运行时（Runtime）使用。</li></ul></li></ol><hr><h3 id="五、收尾阶段" tabindex="-1">五、收尾阶段 <a class="header-anchor" href="#五、收尾阶段" aria-label="Permalink to &quot;五、收尾阶段&quot;">​</a></h3><ol><li><p><strong>触发插件钩子</strong></p><ul><li>调用 <code>done</code> 钩子，通知插件打包完成。</li><li>输出统计信息（Stats），可通过配置或 <code>--stats</code> 控制详细程度。</li></ul></li><li><p><strong>监听模式（Watch Mode）</strong></p><ul><li>如果启用 <code>watch: true</code>，Webpack 会监听文件变化，重新触发编译流程。</li></ul></li></ol><hr><h3 id="流程图解" tabindex="-1">流程图解 <a class="header-anchor" href="#流程图解" aria-label="Permalink to &quot;流程图解&quot;">​</a></h3><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>初始化配置 → 创建Compiler → 启动编译 → 解析入口 → 构建模块依赖图 </span></span>
<span class="line"><span>    ↓                                ↓</span></span>
<span class="line"><span>加载插件         应用Loader转换代码 → 生成Chunk → 优化 → 输出文件</span></span></code></pre></div><hr><h3 id="核心对象与概念" tabindex="-1">核心对象与概念 <a class="header-anchor" href="#核心对象与概念" aria-label="Permalink to &quot;核心对象与概念&quot;">​</a></h3><ul><li><strong>Compiler</strong>：全局唯一的打包控制器，管理生命周期和插件调度。</li><li><strong>Compilation</strong>：单次编译过程的上下文，包含模块、Chunk、生成的资源等信息。</li><li><strong>Module</strong>：代码模块的抽象，包含源码、依赖、ID 等。</li><li><strong>Chunk</strong>：输出文件的代码块，由多个 Module 组成。</li><li><strong>Loader</strong>：文件内容转换器（如转换非 JS 文件）。</li><li><strong>Plugin</strong>：通过钩子介入打包流程，扩展功能。</li></ul><p>通过这一流程，Webpack 将分散的模块整合为可部署的静态资源，同时支持复杂的优化和扩展能力。</p>`,23)]))}const h=e(t,[["render",r]]);export{g as __pageData,h as default};
