Webpack 热更新（Hot Module Replacement, HMR）的核心原理是通过动态替换修改的模块代码，实现**不刷新页面**即可更新应用状态。其流程可拆解为以下几个关键步骤：

---

### 1. **建立通信通道**
- **WebSocket 连接**：Webpack DevServer 启动时，会创建一个 WebSocket 服务端，与浏览器客户端建立长连接。
- **双向通信**：通过 WebSocket 实现服务端与客户端的实时消息传递（如文件修改通知、更新请求等）。

---

### 2. **文件监听与编译**
- **监听文件变化**：Webpack 通过 `watch` 模式实时监听源代码文件的变化。
- **增量编译**：文件修改后，Webpack 仅重新编译受影响的模块，生成新的编译结果（包括更新的模块代码和生成的 `[hash].hot-update.json` 和 `[hash].hot-update.js` 补丁文件）。

---

### 3. **推送更新通知**
- **Hash 对比**：服务端将新编译的 `hash` 值通过 WebSocket 发送给客户端。
- **客户端检查更新**：客户端通过 `window.__webpack_hash__` 对比本地 `hash`，若不一致则发起更新请求。

---

### 4. **获取更新资源**
- **JSONP 动态加载**：客户端通过 `JSONP` 请求获取两个文件：
  1. **`[hash].hot-update.json`**：描述哪些模块需要更新。
  2. **`[hash].hot-update.js`**：包含更新后的模块代码。
- **插入新代码**：动态创建 `<script>` 标签加载补丁脚本，将新模块代码注入运行环境。

---

### 5. **模块替换与热更新**
- **模块热替换**：调用 `HotModuleReplacementPlugin` 生成的 `HMR Runtime` 代码，执行以下操作：
  1. **删除旧模块**：从模块缓存中移除旧模块。
  2. **应用新模块**：将新模块代码加入缓存，替换旧模块。
  3. **冒泡更新**：从被修改的模块开始，向上遍历依赖树，触发所有父模块的 `accept` 回调。
- **自定义处理**：如果模块定义了 `module.hot.accept` 回调（如 React 组件的热更新），则执行自定义更新逻辑（如重新渲染组件但保留状态）。

---

### 6. **异常处理**
- **更新失败回退**：若热更新过程中发生错误（如模块未处理 `accept`），则自动降级为刷新整个页面（Live Reload）。

---

### 关键代码示例
```javascript
// Webpack 配置启用 HMR
devServer: {
  hot: true, // 开启 HMR
  // ...
},
plugins: [
  new webpack.HotModuleReplacementPlugin(), // 注入 HMR Runtime
]

// 模块自定义热更新逻辑（如 React 组件）
if (module.hot) {
  module.hot.accept('./App.js', () => {
    // 重新渲染组件，保留状态
    render(<App />, document.getElementById('root'));
  });
}
```

---

### 流程示意图
```
文件修改 → Webpack 监听并编译 → 服务端推送新 Hash → 客户端请求补丁文件 → 动态加载新模块 → 替换旧模块 → 触发更新回调
```

---

### 核心优势
- **状态保留**：避免页面刷新导致的应用状态丢失（如表单输入、弹窗状态）。
- **快速反馈**：仅更新修改的部分，减少等待完整编译和刷新的时间。
- **开发体验提升**：实现真正的“所见即所得”开发模式。

---

### 总结
Webpack HMR 的本质是**动态模块替换系统**，通过 WebSocket 通信、增量编译、JSONP 加载补丁和模块热替换机制，实现高效的无刷新更新。其设计充分利用了 Webpack 模块化架构和浏览器动态执行能力，是现代前端工程化的重要实践之一。